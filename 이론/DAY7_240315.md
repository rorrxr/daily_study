#DAY7 정리
1. 디자인 패턴 중 구조 패턴에 대해서 설명해주세요.
- 구조패턴(structural patterns)은 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다. 
- 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.

- 구조패턴 종류 
- 어댑터 패턴(Adapter Pattern) : 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.
- 브리지 패턴(Bridge Pattern) : 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있다.
- 합성 패턴(Composite pattern) : 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다.
- 데코레이터 패턴(Decorator Pattern) : 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 할 수 있다.
- 퍼사드 패턴(Facade Pattern) : 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공한다.
- 플라이웨이트 패턴(Flyweight Pattern) : 다수의 유사한 객체를 생성·조작하는 비용을 절감할 수 있다.
- 프록시 패턴(Proxy Pattern) : 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공한다.

ref
https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns

2. 스프링 프레임워크에 대해 설명해주세요.
- 스프링 프레임워크(영어: Spring Framework)는 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로서 간단히 스프링(Spring)이라고도 한다. 
- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하고 있다.
  
3. 트랜잭션의 연산을 수행할 때, 트랜잭션의 상태에 대해서 설명해주세요. (????????????????????????????)
- 트랜잭션의 연산으로는 크게 Commit과 Rollback 두 가지가 있다. 

  1. Commit 연산
 
- Commit 연산은 하나의 트랜잭션이 성공적으로 종료된 후, 데이터베이스가 일관된 상태를 유지할 때 갱신 연산이 완료되었다고 트랜잭션 관리자에게 알려주고 결과를 최종적으로 데이터베이스에 반영하는 연산이다. 
 
2. Rollback 연산
 
- Rollback 연산은 하나의 트랜잭션이 비정상적으로 종료되어 데이터베이스의 일관성을 잃었을 때 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션 수행 이전의 상태로 돌아가는 연산이다. 
- Rollback을 하는 경우엔 해당 트랜잭션을 재시작하거나 폐기한다. 

1. 활성화(Active) : 트랜잭션이 작업을 시작하여 실행 중인 상태
2. 실패(Failed) : 트랜잭션에 오류가 발생하여 실행이 중단된 상태
3. 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
4. 부분 완료(Partially commited) : 트랜잭션의 마지막 연산까지 실행하고 commit 요청이 들어온 직후의 상태. 최종 결과를 데이터베이스에 아직 반영하지 않은 상태.
5. 완료(Commited) : 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

출처: https://rebro.kr/162 [Rebro의 코딩 일기장:티스토리]
  
https://rebro.kr/162 

4. SDN(Software Defined Networking)에 대해서 설명해주세요.
- SDN(Software Defined Network)이란 소프트웨어를 통해 네트워크 리소스를 가상화하고 추상화하는 네트워크 인프라에 대한 접근 방식을 의미한다.

조금 더 쉽게 설명하자면, 소프트웨어 애플리케이션과 API를 이용하여 네트워크를 프로그래밍하고, 중앙에서 전체 네트워크를 제어하고 관리하는 것이다.
5. NFV(Network Function Virtualization)에 대해서 설명해주세요.
- NFV(네트워크 기능 가상화)는 라우터, 방화벽 및 부하 분산 장치와 같은 고가의 전용 하드웨어 장치를 산업 표준 서버에서 가상 머신으로 실행되는 소프트웨어 기반 네트워크 어플라이언스로 대체할 수 있도록 해주는 진화하는 네트워크 접근법입니다.
  
6. 시큐어 코딩(Secure Coding)에 대해서 설명해주세요.
- 시큐어 코딩(secure coding)은 소프트웨어 개발 시 안전한 코드를 제작한다는 의미입니다. 
- 또한 해킹을 비롯한 사이버 공격의 대상이 될 수 있는 소프트웨어의 보안 약점을 출시 이후가 아닌, 개발 단계에서 사전에 제거하는 일련의 보안 활동을 말합니다.
  
7. OWASP(The Open Web Application Security Project)에 대해서 설명해주세요.
- OWASP(Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트입니다.
- OWASP처럼 애플리케이션 보안에만 전념하는 여러 커뮤니티 그룹의 조직이 상당히 커지고 있습니다. 
- OWASP는 가장 큰 오픈소스 웹 애플리케이션 보안 프로젝트로 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하며, 10대 웹 애플리케이션의 취약점(OWASP TOP 10)을 발표합니다.
- OWASP TOP 10은 웹 애플리케이션 취약점 중에서 빈도가 많이 발생하고, 보안상 영향을 크게 줄 수 있는 것들 10가지를 선정한 문서입니다.

8. 데이터베이스 역정규화(denormalization)에 대해서 설명해주세요.
역정규화(denormalization)
- 정규화를 통해 만든 테이블을 성능, 개발 편의성 등을 위해 조작하거나 구조를 바꾸는 것.
- 정규화를 하게 되면 쓰기가 편리해지는 대신, 읽기의 성능을 희생하게 된다.
- 테이블을 나누면 join을 해야 하는데, join에 드는 비용이 크기 때문.
- 즉, 읽기가 자주 일어나는 테이블은 정규화로 인해 성능이 저하되는 경우가 있다. 이때 성능 향상을 위해 가장 마지막 수단으로 시도해볼 수 있는 것이 역정규화를 통한 구조 변경이다.
- 그러나, 역정규화를 하기 전 반드시 정규화를 수행해야 한다. 아예 정규화를 수행하지 않은 테이블은 좋은 형태가 아니며, 정규화가 성능을 저하시킨다고 일반화할 수는 없기 때문이다.

- 장점
-> 읽기에 들어가는 부하나 비용을 줄여 성능을 높일 수 있다.
- 단점
-> 역정규화를 할 경우 반드시 시스템의 복잡도가 훨씬 높아지고, 이는 프로그램이 고장날 가능성일 높이는 요인임을 알아야 한다.
-> 정규화하기 전의 문제를 고스란히 갖게 되기 때문이다(데이터 중복, 역정규화하기 이전의 테이블들이 그대로 남아있음 등).
  
ref
https://velog.io/@clock509/%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94
  
9. OSI 7계층 중 세션(Session) 계층에 대해 설명해주세요.
- 세션  계층(session layer)은  네트워크의  대화  관리자(dialog controller)로서 통신장치들  간의  상호작용을  설정하고  유지하며  동기화한다.
- 세션  계층은  사용자  위주의  연결  서비스를  제공하며  전달  데이터의  확인이나  사용자가  안전하게 대화를  하기  위한  서비스와  같은  부가적인  기능을  제공한다.
  
10. 다음 프로그래밍의 결과는 무엇인가요?
```
#include <stdio.h>
 
int main(){
 
    char* a = "qwer";
    char* b = "qwtety";
    int i, j;
 
    for(int i = 0; a[i] != '\0' ; i++){
        for(int j = 0; b[j] != '\0'; j++){
            if(a[i] == b[j]) printf("%c", a[i]);
        }
    }
}

```
답 : qwe

-> for(int i = 0; a[i] != '\0' ; i++) : a[i]가 공백이 아닐 때까지 반복 
-> for(int j = 0; b[j] != '\0'; j++) : b[j]가 공백이 아닐 때까지 반복
-> if(a[i] == b[j]) printf("%c", a[i]); a[i]와 b[j]에 있는 값이 동일할 때 a[i]를 출력
